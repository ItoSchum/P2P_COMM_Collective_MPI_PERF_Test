%Performance metrics

To estimate the execution time according to Hockney's model,
we used the formula \textbf{t(s) = l + s / b}. In the formula,
\textbf{s} stands for the message size,
\textbf{l} stands for the latency of the network,
\textbf{b} stands for the bandwidth of the network.


\begin{gather*}
    T = \alpha + \beta \\
    \alpha = l = Latency \\
    \beta = \frac{s}{b} = \frac{Message Size}{Bandwidth}
\end{gather*}


Then it came with the quesion "How can we determine the latency and the bandwidth?"
In this benchmark model, it assumes that some process A sends a message to process B, while process B sends message back
The advantage is that it will not require any synchronized clocks between these two processes.
While the disadvantage is that it will presume the communication performance or the costs between two points is totally symmetric.

To determine latency, it reuires to execute the benchmark for itration time equal to zero.

More specifically, to calculate the \textbf{total execution time},
it simply subtracts the end timestamp generated after the for loop of iteration
by the start timestamp, both of which are generated via the function \textbf{MPI\_Time()}.

\begin{equation*}
    \begin{aligned}
        TotalExecutionTime = EndTimeStamp - StartTimeStamp
    \end{aligned}
\end{equation*}

The \textbf{average executioin time} can be calculated via using the message size timed by MAX\_MEASUREMENTS to split the total execution time

\begin{equation*}
    \begin{aligned}
        AverageExecutionTime = \frac{TotalExecutionTime} {MessageSize * MAX\_MEASUREMENTS}
    \end{aligned}
\end{equation*}

The \textbf{bandwidth} can be claculated by using message size timed by its data size to be split by its average execution time.

\begin{equation*}
    \begin{aligned}
        Bandwidth = \frac{MessageSize * sizeof(DataType)} {AverageExecutionTime}
    \end{aligned}
\end{equation*}

We evaluate the scalability of our modeling results for both strong scaling and weak scaling. The strong scaling refers to the case where problem size is fixed and number of processing elements increases. Strong scaling can be used as justification for CPU-bound programs.This type of program don't scale up very well and it's hard to get good performance at large process elements count. The strong scaling efficiency is calculated by
\begin{equation*}
t_1 / ( N * t_N ) * 100\% 
\end{equation*}git 
where $t_1$ represents the time taken to complete one unit of work on a MPI rank and $t_N$ represents the time taken to complete N units of work. 

The weak scaling is the case where workload on each processing elements stays fixed and the amount of processing elements increases to increase the total problem size. Weak scaling is jused as justification for programs that are memory or other system resources bound. This type of programs scales up well at large process elemtns count. The weak scaling efficiency is calculated by
\begin{equation*}
( t_1 / t_N ) * 100\% 
\end{equation*}
where just as the strong scaling efficiency, $t_1$ represents the amount of time taken to complete one unit of work and $t_N$ represents the time taken to complete N units of work on N processing elements.